<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="c++ 基础汇总">




  <meta name="keywords" content="c++,">


<script type="text/javascript">
window.onload=
function(){
    var oDiv = document.getElementById("toc-test"),
    H = 0,
    Y = oDiv
    while (Y) {H += Y.offsetTop; Y = Y.offsetParent}
    window.onscroll = function()
    {
        var s = document.body.scrollTop || document.documentElement.scrollTop
        if(s>H) {
            oDiv.style = "position:fixed;top:0;"
        } else {
            oDiv.style = ""
        }
    }
}
</script>



  <link rel="alternate" href="/atom.xml" title="浩瀚宇宙·AaronChen">




  <link rel="shortcut icon" type="image/x-icon" href="/img/1.jpg?v=1.1">



<link rel="canonical" href="https://hhyz.me/2019/03/17/cpp/">


<meta name="description" content="类1. 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 范围解析运算符 :: 在类里面不写是什么类型，默认是 private 的。 2. 构造函数 constructor类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同">
<meta name="keywords" content="c++">
<meta property="og:type" content="article">
<meta property="og:title" content="c++ 基础汇总">
<meta property="og:url" content="https://hhyz.me/2019/03/17/cpp/index.html">
<meta property="og:site_name" content="浩瀚宇宙·AaronChen">
<meta property="og:description" content="类1. 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 范围解析运算符 :: 在类里面不写是什么类型，默认是 private 的。 2. 构造函数 constructor类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://hhyz.me/img/2019-03-26-stream-1.jpg">
<meta property="og:image" content="https://hhyz.me/img/2019-03-26-stream-2.jpg">
<meta property="og:image" content="https://hhyz.me/img/2019-03-17-pointer-1.jpg">
<meta property="og:updated_time" content="2019-07-02T17:05:20.721Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c++ 基础汇总">
<meta name="twitter:description" content="类1. 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 范围解析运算符 :: 在类里面不写是什么类型，默认是 private 的。 2. 构造函数 constructor类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同">
<meta name="twitter:image" content="https://hhyz.me/img/2019-03-26-stream-1.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  





  


    <title> c++ 基础汇总 - 浩瀚宇宙·AaronChen </title>


    <script>
(function(u, c) {
  var d = document, t = 'script', o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
  o.src = u;
  if (c) { o.addEventListener('load', function(e) { c(e); }); }
  s.parentNode.insertBefore(o, s);
})('//cdn.bootcss.com/pangu/3.3.0/pangu.min.js', function() {
  pangu.spacingPage();
});
</script>


  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">浩瀚宇宙·AaronChen</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="https://www.hhyz.me">
                            
                            
                                Gallery
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          c++ 基础汇总
        
      </h1>

      <time class="post-time">
          Mar 17 2019
      </time>
    </header>



    
            <div class="post-content">
            <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="1-类成员函数"><a href="#1-类成员函数" class="headerlink" title="1. 类成员函数"></a>1. 类成员函数</h2><p>类的成员函数是指那些<strong>把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样</strong>。</p>
<p>类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p>
<p>范围解析运算符 <code>::</code></p>
<p>在类里面不写是什么类型，默认是 private 的。</p>
<h2 id="2-构造函数-constructor"><a href="#2-构造函数-constructor" class="headerlink" title="2. 构造函数 constructor"></a>2. 构造函数 constructor</h2><p>类的构造函数是类的一种特殊的成员函数，<strong>它会在每次创建类的新对象时执行。</strong></p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。</p>
<p><strong>构造函数可用于为某些成员变量设置初始值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line();  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line(<span class="keyword">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Line::setLength( <span class="keyword">double</span> len )</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> Line::getLength( <span class="keyword">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取默认设置的长度</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">// 再次设置长度</span></span><br><span class="line">   line.setLength(<span class="number">6.0</span>); </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>使用初始化列表来初始化字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len): length(len) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法等同于如下语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line::Line( <span class="keyword">double</span> len) </span><br><span class="line">&#123; </span><br><span class="line">	length = len; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, length = "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::C<span class="comment">( double a, double b, double c)</span>: X<span class="comment">(a)</span>, Y<span class="comment">(b)</span>, Z<span class="comment">(c)</span> </span><br><span class="line">&#123; </span><br><span class="line">	.... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-析构函数-destructor"><a href="#3-析构函数-destructor" class="headerlink" title="3. 析构函数 destructor"></a>3. 析构函数 destructor</h2><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。</p>
<p><strong>析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</strong></p>
<h2 id="4-友元函数"><a href="#4-友元函数" class="headerlink" title="4. 友元函数"></a>4. 友元函数</h2><p>类的友元函数是定义在类外部，但<strong>有权访问类的所有私有（private）成员和保护（protected）成员</strong>。</p>
<p>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<p><code>friend class ClassTwo;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line">&#123;</span><br><span class="line">   double width;</span><br><span class="line">public:</span><br><span class="line">   friend void printWidth( Box box );</span><br><span class="line">   void setWidth( double wid );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 成员函数定义</span><br><span class="line">void Box::setWidth( double wid )</span><br><span class="line">&#123;</span><br><span class="line">    width = wid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请注意：printWidth() 不是任何类的成员函数</span><br><span class="line">void printWidth( Box box )</span><br><span class="line">&#123;</span><br><span class="line">   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span><br><span class="line">   cout &lt;&lt; <span class="string">"Width of box : "</span> &lt;&lt; box.width &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box box;</span><br><span class="line"> </span><br><span class="line">   // 使用成员函数设置宽度</span><br><span class="line">   box.setWidth(<span class="number">10.0</span>);</span><br><span class="line">   </span><br><span class="line">   // 使用友元函数输出宽度</span><br><span class="line">   printWidth( box );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<p><code>Width of box : 10</code></p>
<h2 id="5-内联函数"><a href="#5-内联函数" class="headerlink" title="5. 内联函数"></a>5. 内联函数</h2><p>C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，<strong>编译器会把该函数的代码副本放置在每个调用该函数的地方。</strong></p>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
<p>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p>
<p>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。</p>
<p>下面是一个实例，使用内联函数来返回两个数中的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (20,10): "</span> &lt;&lt; Max(<span class="number">20</span>,<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (0,200): "</span> &lt;&lt; Max(<span class="number">0</span>,<span class="number">200</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max (100,1010): "</span> &lt;&lt; Max(<span class="number">100</span>,<span class="number">1010</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h1><p>在C++中，有一个stream这个类，所有的I/O都以这个“流”类为基础的，包括我们要认识的文件I/O.</p>
<p><img src="/img/2019-03-26-stream-1.jpg" alt></p>
<p><img src="/img/2019-03-26-stream-2.jpg" alt></p>
<p>I/O 对象无拷贝或者赋值</p>
<p>stream 这个类有两个重要的运算符：</p>
<ol>
<li>插入器 <code>&lt;&lt;</code></li>
</ol>
<p>　　向流输出数据。比如说系统有一个默认的标准输出流 <code>cout</code>，一般情况下就是指的显示器，所以，<code>cout&lt;&lt;&quot;Write Stdout&quot;&lt;&lt;&#39;\n&#39;</code> 就表示把字符串”Write Stdout”和换行字符(‘\n’)输出到标准输出流。</p>
<ol start="2">
<li>析取器 <code>&gt;&gt;</code></li>
</ol>
<p>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型的数据。</p>
<h2 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a><code>iostream</code></h2><ul>
<li><code>istream</code> 输入流 (<code>cin</code>)</li>
<li><code>ostream</code> 输出流 (<code>cout</code>)</li>
</ul>
<h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a><code>fstream</code></h2><p>　　在 C++ 中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。<br>　　<br>　　<br>ofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>int* pN = &amp;N;</code></p>
<p><code>pN</code> 和 <code>&amp;N</code> 是 <code>int *</code> 类型</p>
<p><code>*pN</code> 是 <code>int</code> 类型</p>
<h2 id="数组的指针"><a href="#数组的指针" class="headerlink" title="数组的指针"></a>数组的指针</h2><p><strong>数组名实际上就是数组数据所在内存区域的首地址</strong>，表示数组在内存中的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nArray[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nArray;</span><br></pre></td></tr></table></figure>

<p>输出为：<code>0x7ffeeeb00ffc</code></p>
<p>可以通过把首地址赋值给指针，然后对该指针进行加减运算，使指针发生偏转指向数组中的其他元素，从而遍历整个数组。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nArray[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;   <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="keyword">int</span>* pIndex = nArray;          <span class="comment">// 将数组的起始地址赋值给指针pIndex</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针指向的地址是："</span>&lt;&lt;pIndex&lt;&lt;<span class="built_in">endl</span>;       <span class="comment">// 输出指针指向的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针所指向的数据的值是："</span>&lt;&lt;*pIndex&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出这个位置上的数据</span></span><br><span class="line"></span><br><span class="line">pIndex++;   <span class="comment">// 对指针进行加运算，使其指向数组中的下一个值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针指向的地址是："</span>&lt;&lt;pIndex&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">// 输出指针指向的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针所指向的数据的值是："</span>&lt;&lt;*pIndex&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出数据</span></span><br></pre></td></tr></table></figure>

<p>输出为 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指针指向的地址是：<span class="number">0016F</span>A38</span><br><span class="line"></span><br><span class="line">指针所指向的数据的值是：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">指针指向的地址是：<span class="number">0016F</span>A3C</span><br><span class="line"></span><br><span class="line">指针所指向的数据的值是：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看到，pIndex 指针初始指向的地址是 <code>0016FA38</code>，也就是 nArray 这个数组的首地址。换句话说，也就是 pIndex 指向的是数组中的第一个数据，所以输出 <code>*pIndex</code> 的值是 1。    </p>
<p>而在对指针进行加 1 运算后，指针指向的地址变为 <code>0016FA3C</code>，它向地址增大的方向偏移了 <strong>4</strong> 个字节，指向了数组中的第二个数据，输出 <code>*pIndex</code>的值自然也就变成了 2。</p>
<p><img src="/img/2019-03-17-pointer-1.jpg" alt></p>
<p>除了指针的加减算术运算之外，常用到的还有指针的关系运算。指针的关系运算通常用 <code>==</code> 或 <code>!=</code> 来判断两个相同类型的指针是否相等，也就是判断它们是否指向同一地址上的同一数据，以此作为条件或循环结构中的条件判断语句。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nArray[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;    <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="keyword">int</span>* pIndex = nArray;           <span class="comment">// 将数组的起始地址赋值给指针pIndex</span></span><br><span class="line"><span class="keyword">int</span>* pEnd = nArray + <span class="number">3</span>;         <span class="comment">// 计算数组的结束地址并赋值给pEnd</span></span><br><span class="line"><span class="keyword">while</span>( pIndex != pEnd )         <span class="comment">// 在while的条件语句中判断两个指针是否相等，</span></span><br><span class="line">                               <span class="comment">// 也就是判断当前指针是否已经偏转到结束地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*pIndex&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">// 输出当前指针指向的数据</span></span><br><span class="line">    <span class="comment">// 对指针进行加1 运算，</span></span><br><span class="line">   <span class="comment">// 使其偏移到下一个内存位置，指向数组中的下一个数据</span></span><br><span class="line">    ++pIndex;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h2><p>c++ 中当定义类对象是指针对象时候，就需要用到 <code>-&gt;</code> 指向类中的成员；当定义一般对象时候时就需要用到 <code>.</code> 指向类中的成员。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　　<span class="keyword">public</span></span><br><span class="line">　　play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义如下：</p>
<p><code>A *p</code> 则使用：<code>p-&gt;play();</code> 左边是结构指针。</p>
<p><code>A p</code> 则使用：<code>p.paly();</code> 左边是结构变量。</p>
<p>总结：</p>
<p>箭头（<code>-&gt;</code>）：左边必须为指针；</p>
<p>点号（<code>.</code>）：左边必须为实体。</p>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的<strong>地址</strong>。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<blockquote>
<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      Box(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">"Constructor called."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;Volume() &gt; box.Volume();</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;     <span class="comment">// Length of a box</span></span><br><span class="line">      <span class="keyword">double</span> breadth;    <span class="comment">// Breadth of a box</span></span><br><span class="line">      <span class="keyword">double</span> height;     <span class="comment">// Height of a box</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Box <span class="title">Box1</span><span class="params">(<span class="number">3.3</span>, <span class="number">1.2</span>, <span class="number">1.5</span>)</span></span>;    <span class="comment">// Declare box1</span></span><br><span class="line">   <span class="function">Box <span class="title">Box2</span><span class="params">(<span class="number">8.5</span>, <span class="number">6.0</span>, <span class="number">2.0</span>)</span></span>;    <span class="comment">// Declare box2</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(Box1.compare(Box2))</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Box2 is smaller than Box1"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Box2 is equal to or larger than Box1"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用变量是一个别名，也就是说，<strong>它是某个已存在变量的另一个名字</strong>。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<blockquote>
<p>C++ 引用 vs 指针<br>引用很容易与指针混淆，它们之间有以下不同：  </p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。</li>
<li>指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
</blockquote>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/c/">c++</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/03/25/ml/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">机器学习汇总</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/01/22/make/">
        <span class="next-text nav-default">make/cmake/qmake</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>


      <div class="post-toc-warp">
        
      <!--noindex-->
          <div class="post-toc" id="toc-test">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#类"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-类成员函数"><span class="nav-text">1. 类成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-构造函数-constructor"><span class="nav-text">2. 构造函数 constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#带参数的构造函数"><span class="nav-text">带参数的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用初始化列表来初始化字段"><span class="nav-text">使用初始化列表来初始化字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-析构函数-destructor"><span class="nav-text">3. 析构函数 destructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-友元函数"><span class="nav-text">4. 友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-内联函数"><span class="nav-text">5. 内联函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stream"><span class="nav-text">stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#iostream"><span class="nav-text">iostream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fstream"><span class="nav-text">fstream</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针"><span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-text">基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的指针"><span class="nav-text">数组的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gt"><span class="nav-text">-&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-指针"><span class="nav-text">this 指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#引用"><span class="nav-text">引用</span></a></li></ol></div>
            

            <div class="back-to-top" id="back-to-top">
              <i class="iconfont icon-up"></i>
            </div>

          </div>
      <!--/noindex-->
      
      </div>


      </div>
      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2019
    <span class="footer-author">haoyu.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/henryhuang/hexo-theme-polarbearsimple">Polar Bear Simple</a>
    </span>
</span>

      </footer>


    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
