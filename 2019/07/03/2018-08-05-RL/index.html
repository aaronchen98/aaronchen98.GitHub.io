<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        强化学习（一）Deep Q-Network - 浩瀚宇宙的博客 | AaronChen&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/header.jpg" />
        </div>
        <div class="name">
            <i>haoyu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-前言"><span class="toc-text">1. 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Optimal-value-function-最优价值函数"><span class="toc-text">5.1 Optimal value function 最优价值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Policy-Iteration-策略迭代"><span class="toc-text">5.2 Policy Iteration 策略迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Value-Iteration-价值迭代"><span class="toc-text">5.3 Value Iteration 价值迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Value-Function-Approximation-价值函数近似"><span class="toc-text">8.1 Value Function Approximation 价值函数近似</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-总结"><span class="toc-text">8.5 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        强化学习（一）Deep Q-Network
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-03 01:05:20</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#强化学习" title="强化学习">强化学习</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote>
<p>虽然将深度学习和增强学习结合的想法在几年前就有人尝试，但真正成功的开端就是DeepMind在NIPS 2013上发表的 <strong><a href="https://link.zhihu.com/?target=http%3A//arxiv.org/abs/1312.5602" target="_blank" rel="noopener">Playing Atari with Deep Reinforcement Learning</a></strong> 一文，在该文中第一次提出Deep Reinforcement Learning 这个名称，并且提出DQN（Deep Q-Network）算法，实现从纯图像输入完全通过学习来玩Atari游戏的成果。之后DeepMind在Nature上发表了改进版的DQN文章<strong>Human-level Control through Deep Reinforcement Learning</strong>，引起了广泛的关注，Deep Reinfocement Learning 从此成为深度学习领域的前沿研究方向。</p>
</blockquote>
<p><strong>智能体 Agent</strong> 来表示一个具备行为能力的物体，比如机器人，无人车，人等等。</p>
<p>那么增强学习考虑的问题就是智能体Agent和 <strong>环境 Environment</strong> 之间交互的任务。</p>
<blockquote>
<p>比如一个机械臂要拿起一个手机，那么机械臂周围的物体包括手机就是环境，机械臂通过外部的比如摄像头来感知环境，然后机械臂需要输出动作来实现拿起手机这个任务。再举玩游戏的例子，比如我们玩极品飞车游戏，我们只看到屏幕，这就是环境，然后我们输出动作（键盘操作）来控制车的运动。</p>
</blockquote>
<p>那么，不管是什么样的任务，<br>都包含了一系列的：</p>
<ul>
<li><strong>动作 Action</strong>           </li>
<li><strong>观察 Observation</strong>     </li>
<li><strong>反馈值 Reward</strong>   </li>
</ul>
<p>所谓的Reward就是Agent执行了动作与环境进行交互后，环境会发生变化，变化的好与坏就用Reward来表示。</p>
<blockquote>
<p>接下来这里用了Observation观察一词而不是环境那是因为Agent不一定能得到环境的所有信息，比如机械臂上的摄像头就只能得到某个特定角度的画面。因此，只能用Observation来表示Agent获取的感知信息。</p>
</blockquote>
<p>只能用 Observation 来表示 Agent 获取的感知信息</p>
<p>每个时间片，Agent 都是根据当前的观察来确定下一步的动作。观察 Observation 的集合就作为Agent的所处的 <strong>状态 State</strong>，因此，<strong>状态 State</strong> 和 <strong>动作 Action</strong> 存在映射关系，也就是一个 state 可以对应一个 action，或者对应不同动作的概率（常常用概率来表示，概率最高的就是最值得执行的动作）。状态与动作的关系其实就是输入与输出的关系，而状态 State 到动作 Action 的过程就称之为一个<strong>策略 Policy</strong>，一般用 \(\pi\) 表示，也就是需要找到以下关系：  </p>
<p>$$a=\pi(s)$$</p>
<p>或者</p>
<p>$$\pi(a|s)$$</p>
<p>其中 <strong>a 是 action，s 是 state</strong>。<br>第一种是一一对应的表示，第二种是概率的表示。</p>
<blockquote>
<p>增强学习的任务就是找到一个最优的策略Policy从而使Reward最多</p>
</blockquote>
<p>我们一开始并不知道最优的策略是什么，因此往往从随机的策略开始，使用随机的策略进行试验，就可以得到一系列的状态,动作和反馈：</p>
<p>$$\{s_1,a_1,r_1,s_2,a_2,r_2,…s_t,a_t,r_t\}$$</p>
<p>这就是一系列的 <strong>样本 Sample</strong>。增强学习的算法就是需要根据这些样本来改进 Policy，从而使得得到的样本中的 Reward 更好。由于这种让 Reward 越来越好的特性，所以这种算法就叫做增强学习Reinforcement Learning。</p>
<br>
## 2. 马尔科夫决策过程

<blockquote>
<p>MDP只需要用一句话就可以说明白，就是 <strong>“未来只取决于当前”</strong>，专业点说就是下一步的状态只取决于当前的状态，与过去的状态没有关系。</p>
</blockquote>
<p><strong>一个状态 \(S_t\) 是Markov当且仅当：</strong></p>
<p><font size="+1">   $$P(s_{t+1}|s_t)=P(s_{t+1}|s_t,s_{t-1},…s_1,s_0)$$  </font></p>
<p>P为概率。简单的说就是下一个状态仅取决于当前的状态和当前的动作。<br>增强学习的问题都可以模型化为MDP的问题</p>
<p><strong>因此 MDP 可以表示为一个元组</strong> \((S, A, P_{sa}, R)\) ：</p>
<ul>
<li>\(S\) ：所有可能状态的集合， \(s \in S\)，\(s\) 表示某个特定状态</li>
<li>\(A\) ：针对每个状态，我们都要做出动作，这些动作的集合就是 \(A\)； \(a \in A\)，有限动作 action 集合， \(a\) 表示某个特定动作</li>
<li>\(P_{sa}\) ：状态转换分布（statetransition distribution），如果我们在状态 \(s\) 中采取了动作 \(a\) ，系统会转移到一个新的状态，状态转换分布描述了转移到哪个状态的概率分布。</li>
<li>\(R\) ：回馈函数（rewardfunction），增强学习的核心概念，描述了动作能够产生的回报。比如 \(R_π(s,a)\) 描述了在状态 \(s\) 下采用策略 \(\pi\) 所对应的动作 \(a\) 的回报，也叫做立即回报，回馈函数可以有不同的表达形式。</li>
<li>\(\pi(s)\rightarrow a\)： 策略 policy，根据当前 state 来产生 action，可表现为  \(a=\pi(s) \) 或 \( \pi(a|s) = P[a|s]\)，后者表示某种状态下执行某个动作的概率</li>
</ul>
<blockquote>
<p>一个基本的 MDP 可以用 \((S,A,P)\) 来表示， \(S \) 表示状态， \(A\)  表示动作， \(P \) 表示状态转移概率，也就是根据当前的状态 \(s_t\) 和 \(a_t\) 转移到 \(s_{t+1}\) 的概率。</p>
</blockquote>
<p>如果我们知道了转移概率 P，也就是称为我们获得了 <strong>模型 Model</strong>，有了模型，未来就可以求解，那么获取最优的动作也就有可能，这种通过模型来获取最优动作的方法也就称为 Model-based 的方法。但是现实情况下，很多问题是很难得到准确的模型的，因此就有 Model-free 的方法来寻找最优的动作。</p>
<br>
## 3. 价值函数


<blockquote>
<p>既然一个状态对应一个动作，或者动作的概率，而有了动作，下一个状态也就确定了。这就意味着每个状态可以用一个确定的值来进行描述。可以由此判断一个状态是好的状态还是不好的状态。</p>
</blockquote>
<p>但是在选取最优策略的过程中，我们只看立即回报并不能判定哪种策略更优，我们希望的是在采取了策略 \(\pi\) 以后，可以使得整个状态序列的折扣回馈最大。</p>
<p>状态的好坏其实等价于对未来回报的期望，<strong>回报 Return</strong> 来表示某个时刻 t 的状态将具备的回报：</p>
<p><font size="+1">    $$G_t = R_{t+1} + \lambda R_{t+2} + … = \sum_{k=0}^\infty\lambda^kR_{t+k+1}$$ </font></p>
<ul>
<li>R 是 Reward 反馈</li>
<li>\(λ\) 是 discount factor 折扣因子，一般小于 1，就是说一般当下的反馈是比较重要的，时间越久，影响越小。</li>
</ul>
<blockquote>
<p>其中 \(λ\) 被称为折扣因子，在经济学上的解释叫做无风险折现率（risk-freeinterest rate），意思是马上得到的钱（回馈）比未来得到钱更有价值。</p>
</blockquote>
<p><strong>以上概念就组成了增强学习的完整描述：</strong>找到一种策略，使得我们能够根据状态 \(s_0, s_1, s_2, …\) 采取策略中对应的动作 \(a_0, a1, a2…，\) 并使 \(G_t\) 的期望值最大化</p>
<p>引出价值函数，对于获取最优的策略Policy这个目标，我们就会有两种方法：</p>
<ul>
<li>直接优化策略 \(\pi(a|s)\) 或者 \(a = \pi(s)\) 使得回报更高</li>
<li>通过估计 value function 来间接获得优化的策略。道理很简单，既然我知道每一种状态的优劣，那么我就知道我应该怎么选择了，而这种选择就是我们想要的策略。</li>
</ul>
<blockquote>
<p>但是现在为了理解DQN，我们将只关注第二种做法，就是估计value function的做法，因为DQN就是基于value function的算法。</p>
</blockquote>
<ol>
<li><strong>状态价值函数</strong> \(V\) ：从状态 \(x_0\)  开始, 所有的动作 \(a\) ，都是执行某个策略 \(π\) 的结果，最后求每个动作带来累积奖赏</li>
<li><strong>动作价值函数</strong> \(Q\) ：从状态 \(x_0\)  开始，先执行动作 \(a_0\) ， 然后再执行某个策略 \(π\) ，再求相应的积累奖赏</li>
</ol>
<br>
### 3.1 State-Value function 状态价值函数

<p>那么实际上除非整个过程结束，否则显然我们无法获取所有的 reward 来计算出每个状态的Return，因此，再引入一个 <strong>概念价值函数 Value Function</strong>，用 <strong>value function</strong>  \(v(s)\)  来表示一个状态未来的潜在价值。</p>
<p>从定义上看，<strong>value function</strong> 就是回报的期望：</p>
<p>$$v(s)  = \mathbb E[G_t|S_t = s]$$</p>
<p>$$V^{\pi}(s) =\mathbb E_{\pi}[ R(s_0, a_0) + γR(s_1, a_1)+ γ^2R(s_2, a_2) + … | s_0= s ]$$</p>
<p>这个函数也被称为<strong>状态价值函数(statevalue function)</strong>，记为 \(V_{\pi}(s)\)。 因为初始状态 \(s\) 和策略 \(\pi\) 是我们给定的，动作 \(a = \pi(s)\) 。</p>
<br>
### 3.2 Action-Value function 动作价值函数

<p><strong>我们更关心在某个状态下的不同动作的价值</strong>。显然。如果知道了每个动作的价值，那么就可以选择价值最大的一个动作去执行了。</p>
<p>这就是 <strong>Action-Value function</strong>  \(Q^\pi(s,a)\) 。那么同样的道理，也是使用 reward 来表示，只是这里的 reward 和之前的 reward 不一样：</p>
<p><strong>这里是执行完动作 action 之后得到的 reward，之前 state 对应的 reward 则是多种动作对应的 reward 的期望值</strong>。显然，动作之后的 reward 更容易理解。</p>
<p>那么，有了上面的定义，动作价值函数就为如下表示：</p>
<p>$$ Q^{\pi}(s,a) = \mathbb E[R_{t+1}+\lambda R_{t+2} + \lambda ^2R_{t+3} + …|S_t = s,A_t=a]$$</p>
<p>$$<br>\begin{align}<br>Q^\pi(s,a) &amp; =  \mathbb E[r_{t+1} + \lambda r_{t+2} + \lambda^2r_{t+3} + … |s,a] \\<br>&amp; = \mathbb E_{s^\prime}[r+\lambda Q^\pi(s^\prime,a^\prime)|s,a]<br>\end{align}<br>$$</p>
<p>这里要说明的是动作价值函数的定义，加了 \(\pi\) ,也就是说是<strong>在策略下的动作价值</strong>。因为对于每一个动作而已，都需要由策略根据当前的状态生成，因此必须有策略的支撑。而前面的价值函数则不一定依赖于策略。当然，如果定义 \(v^\pi(s)\) 则表示在策略 \(\pi\) 下的价值。</p>
<p>那么事实上我们会更多的使用动作价值函数而不是价值函数，因为动作价值函数更直观，更方便应用于算法当中。</p>
<br>
## 4. Bellman 方程

<blockquote>
<p>在上文我们介绍了 Value Function 价值函数，所以为了解决增强学习的问题，一个显而易见的做法就是我们需要估算 Value Function。是的，只要我们能够计算出价值函数，那么最优决策也就得到了。因此，问题就变成了如何计算 Value Function？</p>
</blockquote>
<p>$$P^a_{ss\prime} = P(S_{t+1}=s\prime|S_t =s, A_t =a)$$</p>
<p>还记得回报 Result 的基本定义吗？就是所有 Reward 的累加（带衰减系数 discount factor）</p>
<p>$$G_t = R_{t+1} + \lambda R_{t+2} + … = \sum_{k=0}^\infty\lambda^kR_{t+k+1}$$</p>
<p>那么 Value Function 该如何定义？也很简单，就是期望的回报啊！期望的回报越高，价值显然也就越大，也就越值得去选择。用数学来定义就是如下：</p>
<p>$$v(s) = \mathbb E[G_t|S_t = s]$$</p>
<p>$$v_{\pi}=\sum_{a\in A}P(a|s)\left(R^a_s+\lambda\sum_{s\prime \in S}P^a_{ss\prime}v_{\pi}(s\prime)\right)$$</p>
<p>接下来，我们把上式展开如下：</p>
<p>$$<br>\begin{align}<br> v(s) &amp; = \mathbb E[G_t|S_t = s] \\<br>      &amp; = \mathbb E[R_{t+1}+\lambda R_{t+2} + \lambda ^2R_{t+3} + …|S_t = s] \\<br>      &amp; = \mathbb E[R_{t+1}+\lambda (R_{t+2} + \lambda R_{t+3} + …)|S_t = s] \\<br>      &amp; = \mathbb E[R_{t+1} + \lambda G_{t+1}|S_t = s] \\<br>      &amp; = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s]<br>\end{align}<br>$$</p>
<p>因此，</p>
<p><font size="+1">   $$v(s) = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s]$$  </font></p>
<p>上面这个公式就是Bellman方程的基本形态。从公式上看，<strong>当前状态的价值和 下一步的价值以及当前的反馈Reward有关。</strong></p>
<p>它表明Value Function是可以<strong>通过迭代来进行计算的!!!</strong></p>
<p>总结一下：</p>
<p>$$v_{\pi}(s) = \mathbb E[R_{t+1} + \lambda v_{\pi}(S_{t+1})|S_t = s]$$</p>
<p>$$ q_{\pi}(s,a) = \mathbb E_{\pi}[R_{t+1} +\lambda q_\pi(S_{t+1},A_{t+1})|S_t =s,A_t = a]$$</p>
<br>
## 5. 最优化

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>先简单介绍一下动态规划，因为严格来说，值迭代与策略迭代是用来解决动态规划问题的两种规划方法。而强化学习又有另外一个昵称——就是<strong>拟动态规划</strong>。说白了强化学习就是模拟动态规划算法。</p>
<p>用一句话来总结动态规划就是，对一个复杂问题给出一个一般性的解决办法。它主要由两个性质:</p>
<ul>
<li><strong>最优子结构</strong>：最优解法能被分解到多个子问题中</li>
<li><strong>重叠子问题</strong>：子问题能重复多次且解法能被重复利用、</li>
</ul>
<p>马尔科夫决策过程（MDP）满足以上两个性质，所以任何 MDP 都可以用动态规划来解。动态规划与强化学习的区别就是<strong>动态规划假设 MDP 模型是全知的（即参数可知） 而 强化学习可以使 MDP 未知</strong>。</p>
<p>MDP需要解决的问题有两种：</p>
<ul>
<li>第一种是 prediction，它已知MDP的 \(S,A,P,R,γ\) 以及 policy，目标是算出在每个状态下的 value function(值函数其实就是问题的目标，一般都是跟 reward 有关的函数，例如 Atari 小游戏，一般值函数就是累计的得分的期望。目标一般就是最大化这个值函数。</li>
<li>而第二种是control，它已知 MDP 的 \(S,A,P,R,γ\) 但是 policy 未知（即动作  \(a_t\)  未知），因此它的目标不仅是计算出最优的 value function 而且要给出最优的 Policy。</li>
</ul>
<h3 id="5-1-Optimal-value-function-最优价值函数"><a href="#5-1-Optimal-value-function-最优价值函数" class="headerlink" title="5.1 Optimal value function 最优价值函数"></a>5.1 Optimal value function 最优价值函数</h3><blockquote>
<p>能计算动作价值函数是不够的，因为我们需要的是最优策略，现在求解最优策略等价于求解最优的 value function，找到了最优的 value function，自然而然策略也就是找到。（当然，这只是求解最优策略的一种方法，也就是 value-based approach，由于 DQN 就是 value-based，因此这里只讲这部分，以后我们会看到还有 policy-based 和 model-based 方法。一个就是直接计算策略函数，一个是估计模型，也就是计算出状态转移函数，从而整个MDP过程得解）</p>
</blockquote>
<p>首先是最优动作价值函数和一般的动作价值函数的关系：</p>
<p>$$V^*(s,a) = \max_\pi V^\pi(s,a)$$</p>
<p>$$Q^*(s,a) = \max_\pi Q^\pi(s,a)$$</p>
<p>也就是最优的动作价值函数就是所有策略下的动作价值函数的最大值。通过这样的定义就可以使最优的动作价值的唯一性，从而可以求解整个MDP。</p>
<p>那么套用上一节得到的 value function，可以得到</p>
<p>$$Q^*(s,a) = \mathbb E_{s^\prime}[r+\lambda \max _{a^\prime}Q^*(s^\prime,a^\prime)|s,a]$$</p>
<p>因为最优的Q值必然为最大值，所以，等式右侧的Q值必然为使 \(a′\) 取最大的Q值。</p>
<p>下面介绍基于Bellman方程的两个最基本的算法，策略迭代和值迭代。</p>
<div align="center">
![](/img/2018-08-05-RL-1.jpg)
![](/img/2018-08-05-RL-2.jpg)
<center><small><font color="gray">    </font></small></center>
</div>


<h3 id="5-2-Policy-Iteration-策略迭代"><a href="#5-2-Policy-Iteration-策略迭代" class="headerlink" title="5.2 Policy Iteration 策略迭代"></a>5.2 Policy Iteration 策略迭代</h3><p><strong>策略迭代就是在policy未知的情况下，根据每次的reward学到最优policy。</strong></p>
<p>对一个具体的 MDP 问题，每次先初始化一个策略，根据这个策略计算值函数 \(v(s)\) , 通过这个re值函数来根据贪心策略更新策略，不断迭代最终得到最优策略与最优值函数。总结下来就两个阶段。</p>
<ul>
<li><strong>Policy evaluation</strong> ：根据每一次的给出策略估计 \(v_π\) </li>
<li><strong>Policy improvement</strong>：根据 Greedy poilcy 和之前得到的 \(v_π\) 获得当前策略 \(π′\) </li>
</ul>
<p>Policy Iteration的目的是通过迭代计算value function 价值函数的方式来使policy收敛到最优。</p>
<p><img src="/img/2018-08-05-RL-15.jpg" alt><br><img src="/img/2018-08-05-RL-16.jpg" alt></p>
<p><strong>给一个例子：</strong></p>
<p>下图是一个叫 Small Gridworld 的例子，左上角和右下角是终点， \(γ=1\) ，移动一步 reward 减少1，起始的 random policy 是朝每个能走的方向概率相同，先单独看左边一列，它表示在第 \(k\) 次迭代每个 state上value function 的值，这一列始终采用了 random policy，这里的 value function 就是通过 Bellman Expectation Equation 得到的，考虑 \(k=2\) 的情况， \(-1.7 = -1.0 + 2\times (1/3.0)(-1)\)，\(-2.0 = -1.0 + 4(1/4.0)\times (-1)\) 。而右边一列就是在当前的 value function 情况下通过 greedy 算法找到当前朝哪个方向走更好。</p>
<p><img src="/imf/2018-08-05-RL-17.jpg" alt><br><img src="/img/2018-08-05-RL-18.jpg" alt></p>
<p>Policy Iteration 本质上就是直接使用 Bellman 方程而得到的：</p>
<div align="center">
![](/img/2018-08-05-RL-3.jpg)
<center><small><font color="gray">    </font></small></center>
</div>


<h3 id="5-3-Value-Iteration-价值迭代"><a href="#5-3-Value-Iteration-价值迭代" class="headerlink" title="5.3 Value Iteration 价值迭代"></a>5.3 Value Iteration 价值迭代</h3><p>Value Iteration 则是使用 Bellman 最优方程得到：</p>
<div align="center">
![](/img/2018-08-05-RL-4.jpg)
<center><small><font color="gray">    </font></small></center>
</div>

<p>然后改变成迭代形式：</p>
<div align="center">
![](/img/2018-08-05-RL-5.jpg)
<center><small><font color="gray">    </font></small></center>
</div>
值迭代就是在已知 policy 和 MDP 模型的情况下，根据策略获得最优值函数和最优策略。 
只不过这是确定策略，在值函数 \\(v\_π\\) 取得最大值的 \\(a\_t\\) (策略) 
通过每次迭代bellman方程获得 \\(v\_i\\) , 知道值函数收敛。图解如下：    
<br>
<div align="center">
![](/img/2018-08-05-RL-6.jpg)
<center><small><font color="gray">    </font></small></center>
</div>


<br>
## 6. Q-Value (Quality-Value)

<p>Q Learning的思想完全根据value iteration得到。但要明确一点是value iteration每次都对所有的Q值更新一遍，也就是所有的状态和动作。但事实上在实际情况下我们没办法遍历所有的状态，还有所有的动作，我们只能得到有限的系列样本。因此，只能使用有限的样本进行操作。那么，怎么处理？Q Learning提出了一种更新Q值的办法：</p>
<p><font size="+1">  $$Q(S_{t},A_{t}) \leftarrow Q(S_{t},A_{t})+\alpha({R_{t+1}+\lambda \max _aQ(S_{t+1},a)} - Q(S_t,A_t))$$   </font></p>
<p>虽然根据value iteration计算出target Q值，但是这里并没有直接将这个Q值（是估计值）直接赋予新的Q，而是采用渐进的方式类似梯度下降，朝target迈近一小步，取决于α,这就能够减少估计误差造成的影响。类似随机梯度下降，最后可以收敛到最优的Q值。</p>
<p><strong>具体的算法如下：</strong></p>
<div align="center">
![](/img/2018-08-05-RL-7.jpg)
<center><small><font color="gray">    </font></small></center>
</div>

<p><strong>大致代码流程如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 学习 100 回合</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 初始化 state 的观测值</span></span><br><span class="line">        observation = env.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 更新可视化环境</span></span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 大脑根据 state 的观测值挑选 action</span></span><br><span class="line">            action = RL.choose_action(str(observation))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂)</span></span><br><span class="line">            observation_, reward, done = env.step(action)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># RL 从这个序列 (state, action, reward, state_) 中学习</span></span><br><span class="line">            RL.learn(str(observation), action, reward, str(observation_))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将下一个 state 的值传到下一次循环</span></span><br><span class="line">            observation = observation_</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果掉下地狱或者升上天堂, 这回合就结束了</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结束游戏并关闭窗口</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 定义环境 env 和 RL 方式</span></span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = QLearningTable(actions=list(range(env.n_actions)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始可视化环境 env</span></span><br><span class="line">    env.after(<span class="number">100</span>, update)</span><br><span class="line">    env.mainloop()</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>每一组 <code>(state, action, reward, state_)</code> 为一次序列</p>
<br>
以我们回到之前的流程, 根据 Q 表的估计, 因为在 s1 中, a2 的值比较大, 通过之前的决策方法, 我们在 s1 采取了 a2, 并到达 s2, 这时我们开始更新用于决策的 Q 表, 接着我们并没有在实际中采取任何行为, 而是再想象自己在 s2 上采取了每种行为, 分别看看两种行为哪一个的 Q 值大, 比如说 Q(s2, a2) 的值比 Q(s2, a1) 的大, 所以我们把大的 Q(s2, a2) 乘上一个衰减值 gamma (比如是0.9) 并加上到达s2时所获取的奖励 R (这里还没有获取到我们的棒棒糖, 所以奖励为 0), 因为会获取实实在在的奖励 R , 我们将这个作为我现实中 Q(s1, a2) 的值, 但是我们之前是根据 Q 表估计 Q(s1, a2) 的值. 所以有了现实和估计值, 我们就能更新Q(s1, a2) , 根据 估计与现实的差距, 将这个差距乘以一个学习效率 alpha 累加上老的 Q(s1, a2) 的值 变成新的值. 

<p><strong>但时刻记住, 我们虽然用 maxQ(s2) 估算了一下 s2 状态, 但还没有在 s2 做出任何的行为, s2 的行为决策要等到更新完了以后再重新另外做. 这就是 off-policy 的 Q learning 是如何决策和学习优化决策的过程.</strong></p>
<div align="center">
![](/img/2018-08-05-RL-8.jpg)
<center><small><font color="gray">    </font></small></center>
</div>


<p>$$\text{update = learing_rate * (q_target - q_predict)}$$</p>
<p>$$\text{学习率 * (真实值 - 预测值)}$$</p>
<blockquote>
<p>我们想象 Qlearning 的机器人天生近视眼,  \(\gamma= 1\) 时, 机器人有了一副合适的眼镜, 在 s1 看到的 Q 是未来没有任何衰变的奖励, 也就是机器人能清清楚楚地看到之后所有步的全部价值, 但是当  \(\gamma= 0\) , 近视机器人没了眼镜, 只能摸到眼前的 reward, 同样也就只在乎最近的大奖励, 如果  \(\gamma\)  从 0 变到 1, 眼镜的度数由浅变深, 对远处的价值看得越清楚, 所以机器人渐渐变得有远见, 不仅仅只看眼前的利益, 也为自己的未来着想.</p>
</blockquote>
<br>
## 7. Exploration and Exploitation 探索与利用

<p>在上面的算法中，我们可以看到需要使用某一个policy来生成动作，也就是说这个policy不是优化的那个policy，所以Q-Learning算法叫做Off-policy的算法。另一方面，因为Q-Learning完全不考虑model模型也就是环境的具体情况，只考虑看到的环境及reward，因此是model-free的方法。 </p>
<p>回到policy的问题，那么要选择怎样的 policy 来生成 action 呢？有两种做法：</p>
<ul>
<li>随机的生成一个动作</li>
<li>根据当前的Q值计算出一个最优的动作，这个 policy \(\pi\) 称之为 <strong>greedy policy 贪婪策略</strong>。也就是 \(\pi(S_{t+1}) = arg\max _aQ(S_{t+1},a)\) </li>
</ul>
<p><strong>使用随机的动作就是 exploration</strong>，也就是探索未知的动作会产生的效果，有利于更新Q值，获得更好的policy。</p>
<p>而使用 <strong>greedy policy 也就是 target policy 则是 exploitation</strong>，利用policy，这个相对来说就不好更新出更好的Q值，但可以得到更好的测试效果用于判断算法是否有效。</p>
<p>将两者结合起来就是所谓的 \(\epsilon\ greedy\) 策略， \(\epsilon\) 一般是一个很小的值，作为<strong>选取随机动作的概率值</strong>。可以更改 \(\epsilon\) 的值从而得到不同的 exploration 和 exploitation 的比例。例如 \(\epsilon = 0.1\) 表示 90% 的时间是选择最优策略, 10% 的时间来探索.</p>
<blockquote>
<p>要注意一点就是 egreedy 的 \(\epsilon\) 是不断变小的，也就是随机性不断变小。怎么理解呢？就是一开始需要更多的探索，所以动作偏随机，慢慢的我们需要动作能够有效，因此减少随机。也就是越来越贪婪。<br><strong>例如：</strong><br>INITIAL_EPSILON = 0.5  # starting value of epsilon<br>FINAL_EPSILON = 0.01  # final value of epsilon</p>
</blockquote>
<p>这里需要说明的一点是使用 \(\epsilon-greedy\) 策略是一种极其简单粗暴的方法，对于一些复杂的任务采用这种方法来探索未知空间是不可取的。因此，最近有越来越多的方法来改进这种探索机制。</p>
<br>
## 8. 详解Q-Learning


<h3 id="8-1-Value-Function-Approximation-价值函数近似"><a href="#8-1-Value-Function-Approximation-价值函数近似" class="headerlink" title="8.1 Value Function Approximation 价值函数近似"></a>8.1 Value Function Approximation 价值函数近似</h3><p>在简单分析中，我们使用表格来表示Q(s,a)，但是这个在现实的很多问题上是几乎不可行的，因为状态实在是太多。使用表格的方式根本存不下。</p>
<p>我们有必要对状态的维度进行压缩，解决办法就是 <strong>价值函数近似 Value Function Approximation</strong></p>
<p>就是<strong>用一个函数来表示Q(s,a)</strong>，即：</p>
<p>$$Q(s,a) = f(s,a)$$</p>
<p>f可以是任意类型的函数，比如线性函数：</p>
<p>$$Q(s,a) = w_1s + w_2a + b$$<br>其中 \(w_1,w_2,b\) 是函数 \(f\) 的参数。</p>
<p>通过函数表示，我们就可以无所谓 \(s\) 到底是多大的维度，反正最后都通过矩阵运算降维输出为单值的 \(Q\) 。这就是价值函数近似的基本思路。</p>
<p>如果我们就用 \(w\) 来统一表示函数f的参数，那么就有</p>
<p>$$Q(s,a) = f(s,a,w)$$</p>
<p>为什么叫近似，因为我们并不知道 \(Q\) 值的实际分布情况，本质上就是用一个函数来近似 \(Q\) 值的分布，所以，也可以说是</p>
<p>$$Q(s,a)\approx f(s,a,w)$$</p>
<br>
### 8.2 Q值神经网络化！

<blockquote>
<p>用一个深度神经网络来表示这个函数 \(f\)，即我们可以将状态和动作当成神经网络的输入, 然后经过神经网络分析后得到动作的 Q 值, 这样我们就没必要在表格中记录 Q 值, 而是直接使用神经网络生成 Q 值.还有一种形式的是这样, 我们也能只输入状态值, 输出所有的动作值, 然后按照 Q learning 的原则, 直接选择拥有<strong>最大值的动作</strong>当做下一步要做的动作。一般使用第二种形式。</p>
</blockquote>
<p>以DQN为例，输入是经过处理的4个连续的84x84图像，然后经过两个卷积层，两个全连接层，最后输出包含每一个动作Q值的向量。</p>
<p>用神经网络来表示Q值非常简单，Q值也就是变成用Q网络（Q-Network）来表示。接下来就到了很多人都会困惑的问题，那就是怎么训练Q网络？？？</p>
<p>我们知道，神经网络的训练是一个最优化问题，最优化一个损失函数loss function，也就是标签和网络输出的偏差，目标是让损失函数最小化。为此，我们需要有样本，巨量的有标签数据，然后通过反向传播使用梯度下降的方法来更新神经网络的参数。</p>
<p>所以，要训练Q网络，我们要能够为Q网络提供有标签的样本。</p>
<p>所以，问题变成：</p>
<p><strong>如何为 Q 网络提供有标签的样本？<br>答案就是利用 Q-Learning 算法。</strong></p>
<p>回想一下 Q-Learning 算法，<br>$$Q(S_{t},A_{t}) \leftarrow Q(S_{t},A_{t})+\alpha({R_{t+1}+\lambda \max _aQ(S_{t+1},a)} - Q(S_t,A_t))$$</p>
<p>Q值的更新依靠什么？依靠的是利用 Reward 和 Q 计算出来的目标Q值：</p>
<p>$$\text{Target-Q :  }\ \ R_{t+1}+\lambda \max _aQ(S_{t+1},a)$$</p>
<p>因此，我们把目标Q值作为标签不就完了？我们的目标不就是<strong>让Q值趋近于目标Q值</strong>吗？<br>因此，Q网络训练的损失函数就是：</p>
<div align="center">
![](/img/2018-08-05-RL-9.jpg)
<center><small><font color="gray">  \\(s^\`,a^`\\) 即下一个状态和动作   </font></small></center>
</div>

<p>既然确定了损失函数，也就是cost，确定了获取样本的方式。那么DQN的整个算法也就成型了！接下来就是具体如何训练的问题了！</p>
<br>
**前边提到**，每一组 `(state, action, reward, state_)` 为一次序列：

<ul>
<li><code>state (observation)</code> 为目前状态，传递给 q-eval net 得到预计值 (即输入状态值, 输出所有的动作值)；     </li>
<li><code>state_</code> 为下一步状态，传递给 q-target net 得到目标值，之后可以得到 \(\max _aQ(S_{t+1},a)\) ，在之后得到 \(R_{t+1}+\lambda \max _aQ(S_{t+1},a)\) </li>
</ul>
<p><strong>最终的  \(loss\)  为：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loss = tf.reduce_mean(tf.squared_difference(self.q_target, self.q_eval))</span><br></pre></td></tr></table></figure>

<p><strong>再次注意，q-eval net 和 q-target net 网络结构完全一样，只不过参数更新不同！(即 Fixed Q-targets 方法)</strong></p>
<div align="center">
![](/img/2018-08-05-RL-10.jpg)
<center><small><font color="gray">    </font></small></center>
</div>
<br>
<div align="center">
![](/img/2018-08-05-RL-11.jpg)
<center><small><font color="gray">    </font></small></center>
</div>



<p>最基本的DQN，也就是NIPS 13版本的DQN：</p>
<div align="center">
![](/img/2018-08-05-RL-12.jpg)
<center><small><font color="gray">    </font></small></center>
</div>

<p><strong>那么上面的算法看起来那么长，其实就是反复试验，然后存储数据。接下来数据存到一定程度，就每次随机采用数据，进行梯度下降！</strong></p>
<p>也就是在DQN中增强学习 Q-Learning 算法和深度学习的 SGD 训练是同步进行的！<br>通过 Q-Learning 获取无限量的训练样本，然后对神经网络进行训练。</p>
<p><strong>整体代码结构大致如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_maze</span><span class="params">()</span>:</span></span><br><span class="line">    step = <span class="number">0</span>    <span class="comment"># 用来控制什么时候学习</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">        <span class="comment"># 初始化环境</span></span><br><span class="line">        observation = env.reset()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 刷新环境</span></span><br><span class="line">            env.render()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># DQN 根据观测值选择行为</span></span><br><span class="line">            action = RL.choose_action(observation)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 环境根据行为给出下一个 state, reward, 是否终止</span></span><br><span class="line">            observation_, reward, done = env.step(action)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># DQN 存储记忆</span></span><br><span class="line">            RL.store_transition(observation, action, reward, observation_)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 控制学习起始时间和频率 (先累积一些记忆再开始学习)</span></span><br><span class="line">            <span class="keyword">if</span> (step &gt; <span class="number">200</span>) <span class="keyword">and</span> (step % <span class="number">5</span> == <span class="number">0</span>):</span><br><span class="line">                RL.learn()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将下一个 state_ 变为 下次循环的 state</span></span><br><span class="line">            observation = observation_</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果终止, 就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            step += <span class="number">1</span>   <span class="comment"># 总步数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># end of game</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = DeepQNetwork(env.n_actions, env.n_features,</span><br><span class="line">                      learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                      reward_decay=<span class="number">0.9</span>,</span><br><span class="line">                      e_greedy=<span class="number">0.9</span>,</span><br><span class="line">                      replace_target_iter=<span class="number">200</span>,  <span class="comment"># 每 200 步替换一次 target_net 的参数</span></span><br><span class="line">                      memory_size=<span class="number">2000</span>, <span class="comment"># 记忆上限</span></span><br><span class="line">                      <span class="comment"># output_graph=True   # 是否输出 tensorboard 文件</span></span><br><span class="line">                      )</span><br><span class="line">    env.after(<span class="number">100</span>, run_maze)</span><br><span class="line">    env.mainloop()</span><br><span class="line">    RL.plot_cost()  <span class="comment"># 观看神经网络的误差曲线</span></span><br></pre></td></tr></table></figure>

<br>
### 8.3 Experience Replay 经验回放

<blockquote>
<p>Q learning 是一种 off-policy 离线学习法, 它能学习当前经历着的, 也能学习过去经历过的, 甚至是学习别人的经历. 所以每次 DQN 更新的时候, 我们都可以随机抽取一些之前的经历进行学习. 随机抽取这种做法打乱了经历之间的相关性, 也使得神经网络更新更有效率。</p>
</blockquote>
<p>其将系统探索环境得到的数据储存起来，然后随机采样样本更新深度神经网络的参数（有了一个记忆库之后再开始学习）。</p>
<div align="center">
![](/img/2018-08-05-RL-13.jpg)
<center><small><font color="gray">    </font></small></center>
</div>

<p>Experience Replay 的<strong>动机</strong>是：</p>
<ul>
<li>深度神经网络作为有监督学习模型，要求数据满足独立同分布，</li>
<li>但 Q Learning 算法得到的样本前后是有关系的。为了打破数据之间的关联性，Experience Replay 方法通过存储-采样的方法将这个关联性打破了。</li>
</ul>
<p>之所以加入 experience replay 是因为样本是从游戏中的连续帧获得的，这与简单的 reinforcement learning 问题（比如maze）相比，样本的关联性大了很多，如果没有 experience replay，算法在连续一段时间内基本朝着同一个方向做 gradient descent，那么同样的步长下这样直接计算 gradient 就有可能不收敛。<strong>因此 experience replay 是从一个 memory pool 中随机选取了一些 experience，然后再求梯度</strong>，从而避免了这个问题。</p>
<blockquote>
<p>原文的实验中指出mini batch是32，而replay memory存了最近的1000000帧。</p>
</blockquote>
<br>
### 8.4 Fixed Q-targets

<p>Fixed Q-targets 也是一种打乱相关性的机理, 如果使用 fixed Q-targets, 我们就会在 DQN 中使用到<strong>两个结构完全相同但参数不同的神经网络</strong> (有时差), 预测 Q 估计 的神经网络 <strong>(evaluate net)</strong> 具备<strong>最新的参数</strong>, 而预测 Q 现实 的神经网络 <strong>(target net)</strong> 使用的<strong>参数则是很久以前的</strong>。 </p>
<p>例如一开始有两个完全一样的网络，一个进行训练，另一个不训练，到了训练10000次后，把训练过的网络参数完全复制给冻结的网络，之后仍是一个训练，持续更新参数，一个冻结，每10000次才更新一次。</p>
<p><code>target_net</code> 用于预测 <code>q_target</code> 目标值, 他不会及时更新参数. </p>
<p><code>eval_net</code> 用于预测 <code>q_eval</code> 估计值, 这个神经网络拥有最新的神经网络参数</p>
<div align="center">
![](/img/2018-08-05-RL-14.jpg)



<p><img src="/img/2018-08-05-RL-19.jpg" alt></p>
<h3 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h3><p>在 Q-Learning 算法中，计算经验得分的公式如下：</p>
<p>$$\text{Q(state, action) = Q(state, action) + }\alpha\text{ (R(state, action) + }\gamma \text{ Max[Q(next state, all actions)] - Q(state, action))}$$</p>
<p>当  \(\alpha\)  的值是  \(1\)  时，公式如下：</p>
<p>$$\text{Q(state, action) = R(state, action) +} \gamma\text{ Max[Q(next state, all actions)]}$$</p>
<ul>
<li><code>state</code>： 表示 Agent 当前状态。</li>
<li><code>action</code>： 表示 Agent 在当前状态下要做的行为。</li>
<li><code>next state</code>： 表示 Agent 在 state 状态下执行了 action 行为后达到的新的状态。</li>
<li><code>Q(state, action)</code>： 表示 Agent 在 state 状态下执行了 action 行为后学习到的经验，也就是经验分数。</li>
<li><code>R(state, action)</code>： 表示 Agent 在 state 状态下做 action 动作后得到的即时奖励分数。</li>
<li><code>Max[Q(next state, all actions)]</code>： 表示 Agent 在 next state 状态下，自我的经验中，最有价值的行为的经验分数。</li>
<li><code>Gamma</code>：  \(\gamma\) ，表示折损率，也就是未来的经验对当前状态执行 action 的重要程度。</li>
</ul>
<br>
**算法流程:**

<p>Agent 通过经验去学习。Agent将会从一个状态到另一个状态这样去探索，直到它到达目标状态。我们称每一次这样的探索为一个场景（episode）。</p>
<p>每个场景就是 Agent 从起始状态到达目标状态的过程。每次 Agent 到达了目标状态，程序就会进入到下一个场景中。</p>
<ol>
<li><p>初始化 Q 矩阵，并将初始值设置成 0</p>
</li>
<li><p>设置好参数 γ 和得分矩阵 R</p>
</li>
<li><p>循环遍历场景（episode）：</p>
<ol>
<li><p>随机初始化一个状态 s</p>
</li>
<li><p>如果未达到目标状态，则循环执行以下几步：</p>
<ol>
<li>在当前状态 s 下，随机选择一个行为 a</li>
<li>执行行为 a 得到下一个状态 s`</li>
<li>使用  \(\text{Q(state, action) = R(state, action) +} \gamma\text{ Max[Q(next state, all actions)]}\) 公式计算  \(\text{Q(state, action)}\) </li>
<li>将当前状态 s 更新为 s`</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/21262246" target="_blank" rel="noopener">DQN 从入门到放弃</a></li>
<li><a href="https://blog.csdn.net/suoyan1539/article/details/79571010" target="_blank" rel="noopener">经验回放（Experience replay）</a></li>
<li><a href="http://www.algorithmdog.com/drl#i" target="_blank" rel="noopener">强化学习系列之九:Deep Q Network (DQN)</a></li>
<li><a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/" target="_blank" rel="noopener">莫烦 PYTHON 强化学习 Reinforcement Learning</a></li>
</ol>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/haoyuachen">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/aaronchen98">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://www.linkedin.com/in/浩宇-陈-97b3a9151">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
